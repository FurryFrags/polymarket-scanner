<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Polymarket Arb Scanner (Cloudflare Worker)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; line-height: 1.45; }
    #log { height: 520px; overflow-y: auto; border: 1px solid #ccc; padding: 12px; background: #fff; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12.5px; white-space: pre-wrap; }
    input, select, button { margin: 8px 0; padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
    button { background: #0052FF; color: #fff; border: none; cursor: pointer; border-radius: 8px; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .card { background: #fff; border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    .warn { background:#fff2f2; border:1px solid #ffb3b3; }
    .ok { background:#f2fff5; border:1px solid #b3ffc3; }
    small { color:#444; }
  </style>
</head>
<body>
  <h1>Polymarket Arb Scanner (stable deployment)</h1>

  <div class="card warn">
    <b>Why this works:</b><br/>
    Neocities CSP blocked direct Polymarket fetches. This version calls <code>/api/*</code> on the same origin and a Cloudflare Worker
    proxies requests server-side.
  </div>

  <div class="card">
    <div><b>Status:</b> <span id="status">Booting…</span></div>
    <div><b>Wallet:</b> <span id="walletStatus">Not connected</span></div>
    <div><b>Address:</b> <span id="addr">—</span></div>
    <div><b>Chain:</b> <span id="chain">—</span></div>
    <div><b>Scan interval:</b> <span id="scanMs">2000</span> ms</div>
  </div>

  <div class="row">
    <button id="envBtn">1) Env check</button>
    <button id="apiBtn">2) Test API proxy</button>
    <button id="healthBtn">Health</button>
  </div>

  <div class="row">
    <button id="detectBtn">3) Detect Coinbase provider</button>
    <button id="connectBtn">4) Connect Coinbase Wallet</button>
  </div>

  <div class="row">
    <button id="repromptBtn">Re-prompt accounts</button>
    <button id="disconnectBtn">Disconnect / Reset (UI)</button>
  </div>

  <div class="card">
    <label>Market scan limit (default 200):</label>
    <input id="marketLimit" type="number" min="10" max="300" step="10" value="200" />
    <small>
      200 markets ≈ 400 token_ids, under Polymarket <code>/books</code> max array length 500.
    </small>
    <br/><br/>
    <label>Min profit margin threshold (0.01 = 1%):</label>
    <input id="threshold" type="number" step="0.001" value="0.01" />
    <label>Max USDC budget per trade (estimate only):</label>
    <input id="maxAmount" type="number" value="100" />
    <label>Fee model:</label>
    <select id="feeModel">
      <option value="taker" selected>Taker</option>
      <option value="maker">Maker</option>
    </select>
    <label>Taker fee (bps):</label>
    <input id="takerFeeBps" type="number" min="0" step="1" value="50" />
    <label>Maker fee (bps):</label>
    <input id="makerFeeBps" type="number" min="0" step="1" value="0" />
    <label>Fallback minimum order size (if market missing min size):</label>
    <input id="minSize" type="number" min="0" step="0.01" value="1" />
    <label>Trade slippage allowance (0.01 = 1%):</label>
    <input id="slippage" type="number" step="0.001" value="0.01" />
  </div>

  <div class="row">
    <button id="startBtn">Start scanning</button>
    <button id="stopBtn" disabled>Stop scanning</button>
  </div>

  <div class="card ok">
    <b>Total estimated profits tracked:</b> <span id="totalProfits">0.00</span> USDC
    <br/><small>(Estimate only; trade execution is opt-in and defaults to paper mode.)</small>
  </div>

  <div class="card warn">
    <b>Trade execution (server-side):</b>
    <div><small>Live trading signs and submits orders from the server. Never enable live mode unless you are ready to trade.</small></div>
    <label>
      <input id="paperMode" type="checkbox" checked />
      Paper trading mode (no live orders)
    </label>
    <label>
      <input id="confirmTrade" type="checkbox" />
      I understand this may place real orders and accept the risk
    </label>
    <div><b>Last best opportunity:</b> <span id="bestSummary">None yet</span></div>
    <button id="executeBtn" disabled>Execute best arb (2 orders)</button>
    <small id="tradeStatus">No trade submitted.</small>
  </div>

  <div id="log"></div>

<script>
(() => {
  const BUILD = "cf-worker-proxy-2026-01-06";
  const SCAN_INTERVAL_MS = 2000;
  const MAX_RATE_LIMIT_FAILURES = 3;

  const logEl = document.getElementById("log");
  const statusEl = document.getElementById("status");
  const walletStatusEl = document.getElementById("walletStatus");
  const addrEl = document.getElementById("addr");
  const chainEl = document.getElementById("chain");
  const scanMsEl = document.getElementById("scanMs");
  const totalProfitsEl = document.getElementById("totalProfits");
  const paperModeEl = document.getElementById("paperMode");
  const confirmTradeEl = document.getElementById("confirmTrade");
  const executeBtn = document.getElementById("executeBtn");
  const tradeStatusEl = document.getElementById("tradeStatus");
  const bestSummaryEl = document.getElementById("bestSummary");

  scanMsEl.textContent = String(SCAN_INTERVAL_MS);

  let eth = null;
  let connectedAddress = null;
  let interval = null;
  let lastBestOpportunity = null;
  let totalProfits = Number(localStorage.getItem("totalProfits") || "0") || 0;
  let consecutiveRateLimitFailures = 0;
  totalProfitsEl.textContent = totalProfits.toFixed(2);

  function log(msg) {
    const ts = new Date().toLocaleTimeString();
    logEl.textContent += `[${ts}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
    console.log(msg);
  }

  function setStatus(s) { statusEl.textContent = s; }
  function setWalletStatus(s) { walletStatusEl.textContent = s; }

  function updateTradeUiState() {
    executeBtn.disabled = !confirmTradeEl.checked;
    tradeStatusEl.textContent = paperModeEl.checked
      ? "Paper mode enabled."
      : "Live mode armed (requires confirmation).";
  }

  function parseMaybeJson(v) {
    if (v == null) return null;
    if (Array.isArray(v)) return v;
    if (typeof v === "string") {
      const t = v.trim();
      if (!t) return null;
      try {
        const j = JSON.parse(t);
        return Array.isArray(j) ? j : null;
      } catch {
        // sometimes comma-separated
        if (t.includes(",")) return t.split(",").map(x => x.trim()).filter(Boolean);
      }
    }
    return null;
  }

  function parseFiniteNumber(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function getMarketMinSize(market, fallbackMinSize) {
    const candidates = [
      market?.min_size,
      market?.minSize,
      market?.minimum_size,
      market?.minimumSize,
      market?.min_order_size,
      market?.minOrderSize,
      market?.order_min_size,
      market?.orderMinSize
    ];
    for (const c of candidates) {
      const n = parseFiniteNumber(c);
      if (n != null && n > 0) return n;
    }
    return fallbackMinSize > 0 ? fallbackMinSize : 0;
  }

  function getTickSize(market) {
    const candidates = [
      market?.tick_size,
      market?.tickSize,
      market?.min_tick_size,
      market?.minTickSize,
      market?.price_tick_size,
      market?.priceTickSize
    ];
    for (const c of candidates) {
      const n = parseFiniteNumber(c);
      if (n != null && n > 0) return n;
    }
    return null;
  }

  function roundDownToTick(size, tickSize) {
    if (!(tickSize > 0)) return size;
    const factor = Math.floor(size / tickSize + 1e-12);
    return Math.max(0, factor * tickSize);
  }

  function normalizeAsks(rawAsks) {
    const asks = Array.isArray(rawAsks) ? rawAsks : [];
    return asks
      .map(a => ({
        price: parseFiniteNumber(a?.price),
        size: parseFiniteNumber(a?.size)
      }))
      .filter(a => a.price != null && a.size != null && a.price > 0 && a.size > 0)
      .sort((a, b) => a.price - b.price);
  }

  function summarizeDepth(asks) {
    return asks.reduce((sum, level) => sum + level.size, 0);
  }

  function costForSize(asks, targetSize) {
    if (targetSize <= 0) return null;
    let remaining = targetSize;
    let cost = 0;
    let worstPrice = 0;
    for (const level of asks) {
      if (remaining <= 1e-9) break;
      const take = Math.min(remaining, level.size);
      cost += take * level.price;
      remaining -= take;
      worstPrice = level.price;
    }
    if (remaining > 1e-6) return null;
    return {
      cost,
      avgPrice: cost / targetSize,
      worstPrice
    };
  }

  function maxSizeWithinBudget(asksYes, asksNo, budget, maxSize) {
    let low = 0;
    let high = maxSize;
    for (let i = 0; i < 40; i += 1) {
      const mid = (low + high) / 2;
      if (mid <= 0) {
        low = 0;
        break;
      }
      const yesCost = costForSize(asksYes, mid);
      const noCost = costForSize(asksNo, mid);
      if (!yesCost || !noCost) {
        high = mid;
        continue;
      }
      const totalCost = yesCost.cost + noCost.cost;
      if (totalCost <= budget) {
        low = mid;
      } else {
        high = mid;
      }
    }
    return low;
  }

  async function detectCoinbaseProvider(timeoutMs = 400) {
    // Coinbase docs: multiprovider at window.ethereum.providers, identify via isCoinbaseWallet
    // https://docs.cdp.coinbase.com/... :contentReference[oaicite:10]{index=10} (citation in assistant message, not inside code)
    const w = window;

    // 1) Legacy injected
    if (w.ethereum) {
      if (Array.isArray(w.ethereum.providers) && w.ethereum.providers.length) {
        const cb = w.ethereum.providers.find(p => p && p.isCoinbaseWallet);
        if (cb) return { provider: cb, via: "window.ethereum.providers" };
      }
      if (w.ethereum.isCoinbaseWallet) return { provider: w.ethereum, via: "window.ethereum" };
    }

    // 2) EIP-6963 announce/request (if available)
    const discovered = [];
    function onAnnounce(ev) {
      try {
        const d = ev.detail;
        if (d && d.provider) discovered.push(d);
      } catch {}
    }

    w.addEventListener("eip6963:announceProvider", onAnnounce);
    try { w.dispatchEvent(new Event("eip6963:requestProvider")); } catch {}
    await new Promise(r => setTimeout(r, timeoutMs));
    w.removeEventListener("eip6963:announceProvider", onAnnounce);

    // Prefer Coinbase-ish
    const cb = discovered.find(x =>
      x?.provider?.isCoinbaseWallet ||
      String(x?.info?.name || "").toLowerCase().includes("coinbase")
    );
    if (cb?.provider) return { provider: cb.provider, via: "eip6963" };

    return { provider: null, via: "none" };
  }

  function attachWalletListeners(p) {
    if (!p || !p.on) return;

    p.on("accountsChanged", (accounts) => {
      log(`accountsChanged: ${JSON.stringify(accounts)}`);
      if (Array.isArray(accounts) && accounts[0]) {
        connectedAddress = accounts[0];
        addrEl.textContent = connectedAddress;
        setWalletStatus("Connected");
      } else {
        connectedAddress = null;
        addrEl.textContent = "—";
        setWalletStatus("Not connected");
      }
    });

    p.on("chainChanged", (cid) => {
      log(`chainChanged: ${cid}`);
      chainEl.textContent = String(cid);
    });
  }

  async function connectWallet() {
    setStatus("Connecting wallet…");

    const found = await detectCoinbaseProvider();
    eth = found.provider;

    if (!eth) {
      setStatus("No Coinbase provider found");
      log("No provider detected. Make sure Coinbase Wallet extension is installed/enabled on this HTTPS site.");
      return;
    }

    log(`Using provider via: ${found.via}`);
    attachWalletListeners(eth);

    // Request accounts
    log("Requesting accounts…");
    const accounts = await eth.request({ method: "eth_requestAccounts" });
    connectedAddress = (accounts && accounts[0]) ? accounts[0] : null;

    const chainId = await eth.request({ method: "eth_chainId" });
    chainEl.textContent = String(chainId);

    if (connectedAddress) {
      addrEl.textContent = connectedAddress;
      setWalletStatus("Connected");
      log(`Address: ${connectedAddress}`);
    } else {
      setWalletStatus("No accounts returned");
      log("No accounts returned from eth_requestAccounts.");
    }

    // Try switch to Polygon (0x89)
    if (chainId !== "0x89") {
      log(`Wallet chainId=${chainId}; attempting switch to Polygon (0x89)`);
      try {
        await eth.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x89" }] });
        log("Switched to Polygon.");
      } catch (e) {
        // 4902: chain not added
        if (e && e.code === 4902) {
          log("Polygon not added; adding Polygon Mainnet…");
          await eth.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x89",
              chainName: "Polygon Mainnet",
              rpcUrls: ["https://polygon-rpc.com"],
              nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
              blockExplorerUrls: ["https://polygonscan.com"]
            }]
          });
          log("Added & switched to Polygon.");
        } else {
          log(`Chain switch failed: ${e?.message || e}`);
        }
      }
    }

    setStatus("Wallet ready");
  }

  function disconnectUiOnly() {
    stopScanning();
    eth = null;
    connectedAddress = null;
    addrEl.textContent = "—";
    chainEl.textContent = "—";
    setWalletStatus("Not connected");
    setStatus("Reset complete");
    log("Disconnected (UI reset). Note: EIP-1193 providers do not guarantee a programmatic 'disconnect'. If you need to revoke site access, do it in Coinbase Wallet extension → Connected sites.");
  }

  async function repromptAccounts() {
    if (!eth) {
      log("No provider selected yet. Click Detect/Connect first.");
      return;
    }
    // Some wallets re-open the account chooser for this; some ignore.
    try {
      log("Requesting permissions re-prompt…");
      await eth.request({
        method: "wallet_requestPermissions",
        params: [{ eth_accounts: {} }]
      });
      log("Permissions request sent. Now try Connect again if needed.");
    } catch (e) {
      log(`Re-prompt failed/unsupported: ${e?.message || e}`);
    }
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function apiFetch(path, init, options = {}) {
    const url = new URL(path, location.origin).toString();
    const retries = Number.isFinite(options.retries) ? options.retries : 3;
    const baseDelayMs = Number.isFinite(options.baseDelayMs) ? options.baseDelayMs : 500;
    for (let attempt = 0; attempt <= retries; attempt += 1) {
      try {
        const resp = await fetch(url, init);
        const text = await resp.text();
        let data = null;
        try { data = JSON.parse(text); } catch { data = text; }
        if (!resp.ok) {
          const err = new Error(`HTTP ${resp.status} @ ${path} :: ${typeof data === "string" ? data : JSON.stringify(data)}`);
          err.status = resp.status;
          err.isRateLimit = resp.status === 429;
          err.isRetryable = resp.status === 429 || resp.status >= 500;
          if (err.isRetryable && attempt < retries) {
            const delay = Math.round(baseDelayMs * (2 ** attempt) * (0.75 + Math.random() * 0.5));
            log(`Retrying ${path} in ${delay}ms (status ${resp.status}, attempt ${attempt + 1}/${retries})`);
            await sleep(delay);
            continue;
          }
          throw err;
        }
        return data;
      } catch (e) {
        if (e?.isRetryable || e?.status) {
          throw e;
        }
        throw new Error(`FETCH FAIL @ ${path} :: ${e?.message || e}`);
      }
    }
    throw new Error(`FETCH FAIL @ ${path} :: exhausted retries`);
  }

  async function testApiProxy() {
    setStatus("Testing API proxy…");
    try {
      const gamma = await apiFetch("/api/gamma/markets?limit=1&closed=false", { method: "GET" });
      log(`Gamma OK. Type=${Array.isArray(gamma) ? "array" : typeof gamma}`);

      const clob = await apiFetch("/api/clob/ok", { method: "GET" });
      log(`CLOB OK response: ${typeof clob === "string" ? clob : JSON.stringify(clob)}`);

      setStatus("API proxy OK");
    } catch (e) {
      setStatus("API proxy failed");
      log(String(e?.message || e));
    }
  }

  async function testHealth() {
    setStatus("Checking health…");
    try {
      const health = await apiFetch("/api/health", { method: "GET" });
      const gamma = health?.upstream?.gamma;
      const clob = health?.upstream?.clob;
      const missingEnv = health?.env?.missing || [];
      const overall = health?.ok ? "OK" : "DEGRADED";

      setStatus(`Health: ${overall}`);
      log(`Health check: ${overall}`);
      log(`Gamma: ${gamma?.ok ? "OK" : "FAIL"} (status ${gamma?.status ?? "n/a"})`);
      log(`CLOB: ${clob?.ok ? "OK" : "FAIL"} (status ${clob?.status ?? "n/a"})`);
      if (missingEnv.length) {
        log(`Missing env vars: ${missingEnv.join(", ")}`);
      } else {
        log("Env vars: OK");
      }
    } catch (e) {
      setStatus("Health check failed");
      log(`Health check error: ${e?.message || e}`);
    }
  }

  function extractBinaryTokenIds(m) {
    // Prefer explicit tokens array if present
    if (Array.isArray(m?.tokens) && m.tokens.length >= 2) {
      const yes = m.tokens.find(t => String(t?.outcome).toLowerCase() === "yes")?.token_id;
      const no  = m.tokens.find(t => String(t?.outcome).toLowerCase() === "no")?.token_id;
      if (yes && no) return { yes: String(yes), no: String(no) };
    }

    // Else: map outcomes[] to clobTokenIds[]
    const outcomes = parseMaybeJson(m?.outcomes);
    const clobTokenIds = parseMaybeJson(m?.clobTokenIds);

    if (Array.isArray(outcomes) && Array.isArray(clobTokenIds) && outcomes.length === 2 && clobTokenIds.length === 2) {
      const iYes = outcomes.findIndex(x => String(x).toLowerCase() === "yes");
      const iNo  = outcomes.findIndex(x => String(x).toLowerCase() === "no");
      if (iYes >= 0 && iNo >= 0) {
        return { yes: String(clobTokenIds[iYes]), no: String(clobTokenIds[iNo]) };
      }
    }
    return null;
  }

  async function fetchGammaMarketsPaginated(limit) {
    const results = [];
    const pageSize = Math.min(100, Math.max(10, limit));
    let cursor = null;
    let offset = 0;

    while (results.length < limit) {
      const remaining = limit - results.length;
      const params = new URLSearchParams({
        limit: String(Math.min(pageSize, remaining)),
        active: "true",
        closed: "false"
      });
      if (cursor) {
        params.set("cursor", cursor);
      } else {
        params.set("offset", String(offset));
      }

      const page = await apiFetch(`/api/gamma/markets?${params.toString()}`, { method: "GET" });
      let pageData = [];
      let nextCursor = null;

      if (Array.isArray(page)) {
        pageData = page;
      } else {
        if (Array.isArray(page?.data)) {
          pageData = page.data;
        } else if (Array.isArray(page?.markets)) {
          pageData = page.markets;
        }
        nextCursor = page?.next_cursor ?? page?.nextCursor ?? page?.cursor ?? page?.next ?? null;
      }

      if (pageData.length === 0) {
        break;
      }

      results.push(...pageData);

      if (nextCursor) {
        cursor = nextCursor;
      } else {
        offset += pageData.length;
        if (pageData.length < pageSize) {
          break;
        }
      }
    }

    return results.slice(0, limit);
  }

  async function scanOnce() {
    const marketLimit = Math.max(10, Math.min(300, Number(document.getElementById("marketLimit").value) || 200));
    const threshold = Number(document.getElementById("threshold").value) || 0.01;
    const maxAmount = Number(document.getElementById("maxAmount").value) || 100;
    const feeModel = document.getElementById("feeModel").value;
    const makerFeeBps = Math.max(0, Number(document.getElementById("makerFeeBps").value) || 0);
    const takerFeeBps = Math.max(0, Number(document.getElementById("takerFeeBps").value) || 0);
    const fallbackMinSize = Math.max(0, Number(document.getElementById("minSize").value) || 0);
    const feeRate = (feeModel === "maker" ? makerFeeBps : takerFeeBps) / 10000;

    // 1) Markets (Gamma)
    const markets = await fetchGammaMarketsPaginated(marketLimit);
    if (!Array.isArray(markets) || markets.length === 0) {
      log(`No markets array returned. Type=${typeof markets}`);
      return;
    }

    // 2) Collect binary markets + token ids
    const picked = [];
    const tokenIds = [];
    for (const m of markets) {
      const accepting = (m?.acceptingOrders ?? m?.accepting_orders ?? true);
      if (!accepting) continue;

      const pair = extractBinaryTokenIds(m);
      if (!pair) continue;

      picked.push({
        id: m?.id,
        q: String(m?.question || m?.title || m?.slug || "Unknown market"),
        yes: pair.yes,
        no: pair.no
      });

      tokenIds.push(pair.yes, pair.no);

      // Keep under /books max 500 token_ids :contentReference[oaicite:11]{index=11} (citation in assistant message, not inside code)
      if (tokenIds.length >= 500) break;
    }

    if (picked.length === 0) {
      log("No binary Yes/No markets found in this batch.");
      return;
    }

    // 3) Batch orderbooks (CLOB /books)
    const body = tokenIds.slice(0, 500).map(tid => ({ token_id: String(tid) }));
    const books = await apiFetch(`/api/clob/books`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body)
    });

    if (!Array.isArray(books)) {
      log(`CLOB /books unexpected response: ${typeof books}`);
      return;
    }

    const orderbooks = new Map();
    for (const b of books) {
      const asset = String(b?.asset_id || "");
      if (!asset) continue;
      const asks = normalizeAsks(b?.asks);
      if (asks.length === 0) continue;
      orderbooks.set(asset, asks);
    }

    // 4) Compute arbs
    const theoreticalOpps = [];
    const executableOpps = [];
    for (const m of picked) {
      const asksYes = orderbooks.get(m.yes);
      const asksNo = orderbooks.get(m.no);
      if (!asksYes || !asksNo) continue;
      const bestYes = asksYes[0];
      const bestNo = asksNo[0];
      if (!bestYes || !bestNo) continue;

      const bestSum = bestYes.price + bestNo.price;
      if (!(bestSum > 0 && bestSum < 2)) continue;

      const bestMargin = 1 - bestSum;
      if (bestMargin < threshold) continue;

      let theoreticalSize = Math.min(bestYes.size, bestNo.size);
      theoreticalSize = Math.min(theoreticalSize, maxAmount / bestSum);
      if (theoreticalSize > 0) {
        const theoreticalCost = theoreticalSize * bestSum;
        const theoreticalGross = theoreticalSize - theoreticalCost;
        const theoreticalFee = theoreticalCost * feeRate;
        const theoreticalNet = theoreticalGross - theoreticalFee;
        if (theoreticalNet > 0) {
          theoreticalOpps.push({
            q: m.q,
            marketId: m.id,
            yes: m.yes,
            no: m.no,
            ay: bestYes.price,
            an: bestNo.price,
            size: theoreticalSize,
            net: theoreticalNet,
            margin: bestMargin
          });
        }
      }

      const totalYesDepth = summarizeDepth(asksYes);
      const totalNoDepth = summarizeDepth(asksNo);
      const depthLimit = Math.min(totalYesDepth, totalNoDepth);
      if (!(depthLimit > 0)) continue;

      const maxByBudget = maxSizeWithinBudget(asksYes, asksNo, maxAmount, depthLimit);
      if (!(maxByBudget > 0)) continue;

      const minSize = getMarketMinSize(m, fallbackMinSize);
      const tickSize = getTickSize(m);
      let size = maxByBudget;
      const roundedSize = roundDownToTick(size, tickSize);
      const rounded = roundedSize !== size;
      size = roundedSize;
      if (!(size > 0)) continue;
      if (minSize > 0 && size < minSize) continue;

      const yesFill = costForSize(asksYes, size);
      const noFill = costForSize(asksNo, size);
      if (!yesFill || !noFill) continue;

      const cost = yesFill.cost + noFill.cost;
      const avgSum = cost / size;
      const margin = 1 - avgSum;
      if (margin < threshold) continue;

      const gross = size - cost;
      const fee = cost * feeRate;
      const net = gross - fee;
      if (net <= 0) continue;

      executableOpps.push({
        q: m.q,
        marketId: m.id,
        yes: m.yes,
        no: m.no,
        ay: yesFill.worstPrice,
        an: noFill.worstPrice,
        ayAvg: yesFill.avgPrice,
        anAvg: noFill.avgPrice,
        size,
        net,
        margin,
        rounded,
        tickSize,
        minSize
      });
    }

    if (theoreticalOpps.length === 0) {
      log(`No theoretical arbs this scan. (checked ${picked.length} markets / ${tokenIds.length} tokens)`);
    } else {
      theoreticalOpps.sort((a, b) => b.net - a.net);
      const bestTheoretical = theoreticalOpps[0];
      log(`BEST THEORETICAL: "${bestTheoretical.q.slice(0, 80)}${bestTheoretical.q.length > 80 ? "…" : ""}" | ${(bestTheoretical.margin * 100).toFixed(2)}% margin | ~${bestTheoretical.net.toFixed(2)} USDC net est`);
    }

    if (executableOpps.length === 0) {
      log(`No executable arbs this scan. (checked ${picked.length} markets / ${tokenIds.length} tokens)`);
      lastBestOpportunity = null;
      bestSummaryEl.textContent = "None yet";
      return;
    }

    executableOpps.sort((a, b) => b.net - a.net);
    const best = executableOpps[0];

    const roundNote = best.rounded && best.tickSize
      ? ` | rounded to tick ${best.tickSize}`
      : "";
    const minNote = best.minSize > 0 ? ` | min size ${best.minSize}` : "";
    log(`BEST EXECUTABLE: "${best.q.slice(0, 80)}${best.q.length > 80 ? "…" : ""}" | ${(best.margin * 100).toFixed(2)}% margin | ~${best.net.toFixed(2)} USDC net est${roundNote}${minNote}`);
    lastBestOpportunity = best;
    bestSummaryEl.textContent = `${best.q.slice(0, 60)}${best.q.length > 60 ? "…" : ""} | ${(best.margin * 100).toFixed(2)}%`;
    // Track estimate
    totalProfits += best.net;
    totalProfitsEl.textContent = totalProfits.toFixed(2);
    localStorage.setItem("totalProfits", String(totalProfits));
  }

  async function scanLoopTick() {
    try {
      await scanOnce();
      if (consecutiveRateLimitFailures > 0) {
        consecutiveRateLimitFailures = 0;
        setStatus("Scan recovered");
      }
    } catch (e) {
      if (e?.isRateLimit || e?.status === 429) {
        consecutiveRateLimitFailures += 1;
        setStatus(`Rate limited (${consecutiveRateLimitFailures}/${MAX_RATE_LIMIT_FAILURES}). Retrying...`);
        log(`Rate limit hit: ${e?.message || e}`);
        if (consecutiveRateLimitFailures >= MAX_RATE_LIMIT_FAILURES) {
          setStatus("Paused due to repeated rate limits. Click Start to resume.");
          log("Pausing scanning after repeated rate limits.");
          stopScanning();
        }
        return;
      }
      if (e?.status >= 500) {
        log(`Server error: ${e?.message || e}`);
      } else {
        log(String(e?.message || e));
      }
    }
  }

  function startScanning() {
    stopScanning();
    consecutiveRateLimitFailures = 0;
    interval = setInterval(scanLoopTick, SCAN_INTERVAL_MS);
    // run immediately too
    scanLoopTick().catch(() => {});
    document.getElementById("startBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;
    log(`Scanning started (${SCAN_INTERVAL_MS}ms)`);
  }

  function stopScanning() {
    if (interval) clearInterval(interval);
    interval = null;
    document.getElementById("startBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
    log("Scanning stopped");
  }

  async function executeBestTrade() {
    if (!lastBestOpportunity) {
      log("No best opportunity available yet.");
      return;
    }

    if (!confirmTradeEl.checked) {
      log("Trade confirmation checkbox not selected.");
      return;
    }

    if (!paperModeEl.checked) {
      const ok = window.confirm("You are about to place LIVE orders via the server. Continue?");
      if (!ok) {
        log("Live trade canceled by user.");
        return;
      }
    }

    const slippage = Number(document.getElementById("slippage").value) || 0;
    const { marketId, yes, no, ay, an, size } = lastBestOpportunity;

    const orders = [
      { tokenId: yes, side: "buy", price: ay },
      { tokenId: no, side: "buy", price: an }
    ];

    tradeStatusEl.textContent = "Submitting trade...";

    for (const [index, order] of orders.entries()) {
      const payload = {
        marketId,
        tokenId: order.tokenId,
        side: order.side,
        size,
        price: order.price,
        slippage,
        paper: paperModeEl.checked,
        clientOrderId: `arb-${Date.now()}-${index + 1}`
      };

      try {
        const resp = await apiFetch("/api/trade/execute", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
        log(`Trade response (${order.tokenId}): ${JSON.stringify(resp)}`);
      } catch (e) {
        log(`Trade failed (${order.tokenId}): ${e?.message || e}`);
        tradeStatusEl.textContent = "Trade submission failed.";
        return;
      }
    }

    tradeStatusEl.textContent = paperModeEl.checked
      ? "Paper trade logged."
      : "Live trade submitted.";
  }

  // UI
  document.getElementById("envBtn").addEventListener("click", () => {
    log("=== ENV CHECK ===");
    log(`build: ${BUILD}`);
    log(`location.href: ${location.href}`);
    log(`protocol: ${location.protocol}`);
    log(`origin: ${location.origin}`);
    log(`isSecureContext: ${window.isSecureContext}`);
    log(`userAgent: ${navigator.userAgent}`);
    log(`online: ${navigator.onLine}`);
    log("=== END ===");
  });

  document.getElementById("apiBtn").addEventListener("click", testApiProxy);
  document.getElementById("healthBtn").addEventListener("click", testHealth);

  document.getElementById("detectBtn").addEventListener("click", async () => {
    log("=== WALLET DETECTION ===");
    log(`Legacy window.ethereum present: ${!!window.ethereum}`);
    log(`Legacy providers count: ${Array.isArray(window.ethereum?.providers) ? window.ethereum.providers.length : 0}`);

    const found = await detectCoinbaseProvider();
    log(`Best candidate: ${found.provider ? "Coinbase Wallet" : "none"} (via ${found.via})`);
    log("=== END ===");
  });

  document.getElementById("connectBtn").addEventListener("click", async () => {
    try {
      await connectWallet();
    } catch (e) {
      log(`Connect error: ${e?.message || e}`);
      setStatus("Connect failed");
    }
  });

  document.getElementById("repromptBtn").addEventListener("click", repromptAccounts);
  document.getElementById("disconnectBtn").addEventListener("click", disconnectUiOnly);

  document.getElementById("startBtn").addEventListener("click", startScanning);
  document.getElementById("stopBtn").addEventListener("click", stopScanning);
  executeBtn.addEventListener("click", executeBestTrade);
  confirmTradeEl.addEventListener("change", updateTradeUiState);
  paperModeEl.addEventListener("change", updateTradeUiState);

  // Boot
  setStatus("Ready");
  log(`Running build: ${BUILD}`);
  log(`Scan interval: ${SCAN_INTERVAL_MS}ms`);
  updateTradeUiState();
})();
</script>
</body>
</html>
